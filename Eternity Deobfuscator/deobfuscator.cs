using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Security.Cryptography;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;

Console.WriteLine("Sample Path: ");
String sample_path = Console.ReadLine();

ModuleContext modCtx = ModuleDef.CreateModuleContext();
ModuleDefMD module = ModuleDefMD.Load(sample_path, modCtx);

var assembly = AssemblyDef.Load(sample_path);


List<String> strings = new List<String>();
List<String> keys = new List<String>();
List<Int64> offsets = new List<Int64>();



foreach (TypeDef typeDef in module.Types)
{
    foreach (MethodDef methodDef in from m in typeDef.Methods where m.HasBody select m)
    {
        //Console.WriteLine(methodDef.Name);

        for (int i = 0; i < methodDef.Body.Instructions.Count; i++)
        {

           
            if (methodDef.Body.Instructions[i].OpCode == OpCodes.Call)
            {
                if (methodDef.Body.Instructions[i].Operand.GetType().ToString() == "dnlib.DotNet.MethodDefMD")
                {
                    try 
                    {
                        MethodDef my_method = (MethodDef)methodDef.Body.Instructions[i].Operand;
                        if (my_method.Body.Instructions.Count == 2 && my_method.Body.Instructions[0].Operand != "" && methodDef.Body.Instructions[i + 1].OpCode == OpCodes.Call && (methodDef.Body.Instructions[i + 2].OpCode == OpCodes.Call || methodDef.Body.Instructions[i + 2].OpCode == OpCodes.Ldc_I8))
                        {
                            //Console.WriteLine(methodDef.Body.Instructions.Count.ToString() + " " + methodDef.Name);

                            if (my_method.Body.Instructions[0].Operand.ToString().EndsWith("=>"))
                            {
                                keys.Add(my_method.Body.Instructions[0].Operand.ToString());
                            }
                            else
                            {
                                strings.Add(my_method.Body.Instructions[0].Operand.ToString());
                            }
                        }
                    }
                    catch(Exception e)
                    {
                        ;
                    }
                   
                }
            }
            else if (methodDef.Body.Instructions[i].OpCode == OpCodes.Ldc_I8)
            {
                if (methodDef.Body.Instructions[i-3].OpCode == OpCodes.Call && methodDef.Body.Instructions[i-2].OpCode == OpCodes.Call && methodDef.Body.Instructions[i-1].OpCode == OpCodes.Call)
                {
                    offsets.Add(Convert.ToInt64(methodDef.Body.Instructions[i].Operand.ToString()));
                }
            }
        }
    }
}


List<String> decrypted_strings = new List<String>();

for (int i = 0; i < strings.Count; i++)
{
    //Console.WriteLine(SSD(DS(strings[i], keys[i]), offsets[i]));
    decrypted_strings.Add(SSD(DS(strings[i], keys[i]), offsets[i]));
}

Console.WriteLine(decrypted_strings.Count);
int index_string = 0;

foreach (TypeDef typeDef in module.Types)
{
    foreach (MethodDef methodDef in from m in typeDef.Methods where m.HasBody select m)
    {
        //Console.WriteLine(methodDef.Name);

        for (int i = 0; i < methodDef.Body.Instructions.Count; i++)
        {
            if (methodDef.Body.Instructions[i].OpCode == OpCodes.Call && methodDef.Body.Instructions[i + 1].OpCode == OpCodes.Call && methodDef.Body.Instructions[i + 2].OpCode == OpCodes.Call && methodDef.Body.Instructions[i + 3].OpCode == OpCodes.Ldc_I8 && methodDef.Body.Instructions[i + 4].OpCode == OpCodes.Call)
            {
                Console.WriteLine(methodDef.Body.Instructions.Count.ToString() + " " + methodDef.Name + " " + methodDef.Body.Instructions[i].Operand.ToString() + " " + i.ToString() + " " + decrypted_strings[index_string]);
                methodDef.Body.Instructions[i].OpCode = OpCodes.Ldstr;
                methodDef.Body.Instructions[i].Operand = decrypted_strings[index_string];
                methodDef.Body.Instructions[i+1].OpCode = OpCodes.Nop;
                methodDef.Body.Instructions[i+2].OpCode = OpCodes.Nop;
                methodDef.Body.Instructions[i+3].OpCode = OpCodes.Nop;
                methodDef.Body.Instructions[i+4].OpCode = OpCodes.Nop;
                index_string++;

            }
        }
    }
}

var options = new ModuleWriterOptions(assembly.Modules[0]);
options.MetadataOptions.Flags |= MetadataFlags.KeepOldMaxStack;


module.Write(sample_path+"_deobfuscated", options);


static string SSD(string A_0, long A_1)
{
    char[] array = A_0.ToCharArray();
    for (int i = -66706 + 66706; i < array.Length; i += -67639 + 67640)
    {
        int num = Convert.ToInt32(array[i]);
        int num2 = Convert.ToInt32(A_1);
        if (num + num2 < -65565 + 65821 && num - num2 > -84910 + 84910)
        {
            array[i] = Convert.ToChar(num - num2);
        }
        array[i] = (char.IsUpper(array[i]) ? char.ToLower(array[i]) : char.ToUpper(array[i]));
    }
    Array.Reverse(array);
    return string.Join<char>(string.Empty, array);
}

static string DS(string A_0, string A_1)
{
    byte[] key = Convert.FromBase64String(A_1.Remove(A_1.Length - (-22643 + 22644), -17481 + 17482).Remove(-25384 + 25384, -31515 + 31516));
    byte[] array = Convert.FromBase64String(A_0);
    string @string;
    using (AesCryptoServiceProvider aesCryptoServiceProvider = new AesCryptoServiceProvider
    {
        Key = key,
        BlockSize = -8580 + 8708,
        Mode = (CipherMode)(-66707) + 66708,
        Padding = (PaddingMode)(-17986) + 17988
    })
    {
        byte[] array2 = new byte[aesCryptoServiceProvider.BlockSize / (-85424 + 85432)];
        Array.Copy(array, -75385 + 75385, array2, -93841 + 93841, array2.Length);
        using (ICryptoTransform cryptoTransform = aesCryptoServiceProvider.CreateDecryptor(aesCryptoServiceProvider.Key, array2))
        {
            using (MemoryStream memoryStream = new MemoryStream())
            {
                using (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, (CryptoStreamMode)(-86348) + 86349))
                {
                    using (BinaryWriter binaryWriter = new BinaryWriter(cryptoStream))
                    {
                        binaryWriter.Write(array, array2.Length, array.Length - array2.Length);
                    }
                    @string = Encoding.UTF8.GetString(memoryStream.ToArray());
                }
            }
        }
    }
    return @string;
}
