# Idea from: https://github.com/AGDCservices/Ghidra-Scripts/blob/master/Preview_Function_Capabilities.py
# If you have some "Key Error" logs, open the "functions_error.txt", you will find a ready copy and paste key:value to add in the dictionary!


import idaapi
import ida_kernwin
import ida_ida
import idc
import idautils
import ida_nalt
import ida_funcs
class myplugin_t(idaapi.plugin_t):
    flags = idaapi.PLUGIN_UNL
    comment = "Automatically renames a function to get a preview of its capabilities"
    help="https://github.com/Finch4/Malware-Analysis-Reports"
    wanted_name = "Functions Capabilities Preview"
    wanted_hotkey = "Alt-F4"

    
    def init(self):
        idaapi.msg("init() called!\n")
        return idaapi.PLUGIN_OK
    


    def run(self, arg):
        apiPurposeDict = {
        'socket':'netwB',

        'WSAStartup':'netwC',
        'connect':'netwC',
        'InternetOpen':'netwC',
        'InternetConnect':'netwC',
        'InternetOpenURL':'netwC',
        'HttpOpenRequest':'netwC',
        'WinHttpConnect':'netwC',
        'WinHttpOpenRequest':'netwC',

        'bind':'netwL',
        'listen':'netwL',
        'accept':'netwL',

        'send':'netwS',
        'sendto':'netwS',
        'InternetWriteFile':'netwS',
        'HttpSendRequest':'netwS',
        'WSASend':'netwS',
        'WSASendTo':'netwS',
        'WinHttpSendRequest':'netwS',
        'WinHttpWriteData':'netwS',

        'recv':'netwR',
        'recvfrom':'netwR',
        'InternetReadFile':'netwR',
        'HttpReceiveHttpRequest':'netwR',
        'WSARecv':'netwR',
        'WSARecvFrom':'netwR',
        'WinHttpReceiveResponse':'netwR',
        'WinHttpReadData':'netwR',
        'URLDownloadToFile':'netwR',

        'inet_addr':'netwM',
        'htons':'netwM',
        'htonl':'netwM',
        'ntohs':'netwM',
        'ntohl':'netwM',


        'RegOpenKey':'regH',

        'RegQueryValue':'regR',
        'RegGetValue':'regR',
        'RegEnumValue':'regR',

        'RegSetValue':'regW',
        'RegSetKeyValue':'regW',

        'RegDeleteValue':'regD',
        'RegDeleteKey':'regD',
        'RegDeleteKeyValue':'regD',

        'RegCreateKey':'regC',

        'CreateFile':'fileH',
        'fopen':'fileH',

        'fscan':'fileR',
        'fgetc':'fileR',
        'fgets':'fileR',
        'fread':'fileR',
        'ReadFile':'fileR',

        'flushfilebuffers':'fileW',
        'fprintf':'fileW',
        'fputc':'fileW',
        'fputs':'fileW',
        'fwrite':'fileW',
        'WriteFile':'fileW',

        'DeleteFile':'fileD',

        'CopyFile':'fileC',

        'MoveFile':'fileM',

        'FindFirstFile':'fileE',
        'FindNextFile':'fileE',

        'strcmp':'strC',
        'strncmp':'strC',
        'stricmp':'strC',
        'wcsicmp':'strC',
        'mbsicmp':'strC',
        'lstrcmp':'strC',
        'lstrcmpi':'strC',

        'OpenService':'servH',

        'QueryServiceStatus':'servR',
        'QueryServiceConfig':'servR',

        'ChangeServiceConfig':'servW',
        'ChangeServiceConfig2':'servW',

        'CreateService':'servC',

        'DeleteService':'servD',

        'StartService':'servS',

        'CreateToolhelp32Snapshot':'procE',
        'Process32First':'procE',
        'Process32Next':'procE',

        'OpenProcess':'procH',

        'CreateProcess':'procC',
        'CreateProcessAsUser':'procC',
        'CreateProcessWithLogon':'procC',
        'CreateProcessWithToken':'procC',
        'ShellExecute':'procC',


        'ReadProcessMemory':'procR',

        'WriteProcessMemory':'procW',

        'CreateThread':'threadC',
        'beginthread':'threadC',

        'OpenThread':'threadO',

        'SuspendThread':'threadS',

        'ResumeThread':'threadR',
    }
        
        for function in idautils.Functions():
            function_name = idc.get_func_name(function)
            if function_name.startswith("sub"):
                function_start = idc.get_func_attr(function, idc.FUNCATTR_START)
                function_end = idc.get_func_attr(function, idc.FUNCATTR_END)
                function_name_new = ""
                functions_error = set()
                #idaapi.msg(f"{function_name} - {hex(function_start)} - {hex(function_end)}\n")
                for i in range(function_start, function_end):
                    if idc.print_insn_mnem(i) == "call" and not "word" in str(idc.print_operand(i, 0)) and not "sub" in str(idc.print_operand(i, 0)):
                        #idaapi.msg(f"{idc.print_insn_mnem(i)} - {idc.print_operand(i, 0)}\n")
                        try:
                            #idaapi.msg(str(idc.print_operand(i, 0)).replace("Ex","").replace("_","").replace("cs:","").replace("A","").replace("W","")+"\n")
                            key = str(idc.print_operand(i, 0)).replace("Ex","").replace("_","").replace("cs:","")
                            if key[-1] == "W" or key == "A":
                                key = key[:-1]
                            if apiPurposeDict[key]:
                                function_name_new += "_"+apiPurposeDict[str(idc.print_operand(i, 0)).replace("Ex","").replace("_","").replace("cs:","")]
                        except KeyError:
                            idaapi.msg(f' Key Error for {key}\n')
                            open("functions_error.txt","a").write("'"+key+"'"+":"+"'"+key.lower()+"',")
                idc.set_name(function_start, function_name_new, idc.SN_NOWARN)
                idaapi.msg(f"{function_name} -> {function_name_new}\n")
                

            
        
        

    def term(self):
        idaapi.msg("term() called!\n")
        
def PLUGIN_ENTRY():
    return myplugin_t()
